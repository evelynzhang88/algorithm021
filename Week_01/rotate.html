<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script type="text/javascript">

    // var rotate = function (nums, k) {
    //   let temp = 0
    //   let prevNum = 0
    //   for (let i = 0; i < k; i++) {
    //     prevNum = nums[nums.length - 1]
    //     for (let j = 0; j < nums.length; j++) {
    //       temp = nums[nums.length - j - 2]
    //       nums[nums.length - j - 1] = temp
    //     }
    //     nums[0] = prevNum
    //   }
    //   return nums;
    // };

    // console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3))


    // public class Solution {
    //   public void rotate(int[] nums, int k) {
    //     int temp, previous;
    //     for (int i = 0; i < k; i++) {
    //       previous = nums[nums.length - 1];
    //       for (int j = 0; j < nums.length; j++) {
    //         temp = nums[j];
    //         nums[j] = previous;
    //         previous = temp;
    //       }
    //     }
    //   }
    // }

    // var rotate = function (nums, k) {
    //   let a = new Array(nums.length)

    //   for (i = 0; i < nums.length; i++) {
    //     a[(i + k) % nums.length] = nums[i]
    //   }
    //   console.log(a)
    //   for (let j = 0; j < nums.length; j++) {
    //     nums[j] = a[j]
    //   }

    //   return nums
    // };
    // console.log(rotate([1,2,3,4,5,6,7], 3))

    // 删除最外层括号
    // 用栈来做 先删选出原语字符串数组
    // 去除原语字符串最外层括号 1620
    // var removeOuterParentheses = function (S) {
    //   if (S === '') {
    //     return S
    //   }
    //   // 匹配符
    //   let matchString = new Map([[")", "("]])

    //   // 原语字符串
    //   let PrimitiveArr = []
    //   let temp = []
    //   let newArr = []
    //   // let newString = ''
    //   S.split('').forEach(element => {
    //     if ((temp.length > 0) && (temp[temp.length - 1] === matchString.get(element))) {
    //       temp.pop()
    //     } else {
    //       temp.push(element)
    //     }
    //     newArr.push(element)
    //     if (newArr.length > 0 && temp.length === 0) {
    //       PrimitiveArr.push(newArr.join(''))
    //       temp = [] // 清空
    //       newArr = []
    //     }
    //   });


    //   console.log(PrimitiveArr, 'PrimitiveArr')
    //   // 删除原语字符串的外扩号
    //   let resultArr = []
    //   PrimitiveArr.forEach((item) => {
    //     let resultItem = item.toString().substring(1, item.length - 1)
    //     resultArr.push(resultItem)
    //   })

    //   return resultArr.join('')
    // };

    // console.log(removeOuterParentheses('()(())'))

    // k个数翻转链表
    let linkList = {
      val: 1,
      next: {
        val: 2,
        next: {
          val: 3,
          next: {
            val: 4,
            next: {
              val: 5,
              next: {
                val: 6,
                next: null
              }
            }
          }
        }
      }
    }

    // // 1->2->3
    // var reverseKGroup = function (head, k) {
    //   let i = 1
    //   // head = head.next
    //   // console.log(head)
    //   let temp = []
    //   let result = {}
    //   while (head.next !== null) {
    //     temp.push(head)
    //     // temp.next=head
    //     console.log(temp, i, 'temp i')
    //     if (i % k === 0) {
    //       // temp.next = head

    //       for (let j = 0; j < k; j++) {
    //         result.val = temp[k - j - 1].val;
    //         temp.pop()
    //         if (temp.length === 0) {
    //           result.next = null
    //         } else {
    //           result.next = result
    //         }
    //       }
    //     }
    //     // console.log(result, i)
    //     head = head.next
    //     i++;

    //   }
    // };

    // reverseKGroup(linkList, 2)

    // 反转链表
    var reverseList = function (head) {
      let newhead = {}
      let initHead = head
      while (head.next !== null) {
        // 
        head = head.next
        if (head.next === null) {
          // console.log()
          while (head.next === initHead) {
            head.next = head
            newhead.next = head
          }

        }
      }
      console.log(newhead)
    };

    // reverseList(linkList)

    // 有效的字母异位词:两个字符串排序后相等
    // 思路: 1. 循环t，判断t中的每个字符是否存在在字符串s中
    // 思路: 2. map方式
    // var isAnagram = function (s, t) {
    //   let isExist = true
    //   t.split('').forEach((item, index) => {
    //     if(s.indexOf(item) < 0){
    //       console.log(item, item.indexOf(s))
    //       isExist = false
    //     }
    //   })
    //   return isExist
    // };

    // var isAnagram = function (s, t) {
    //   let aS = {}
    //   let aT = {}
    //   let isExist = true
    //   if (s.length !== t.length) {
    //     isExist = false
    //     return isExist
    //   }
    //   s.split('').forEach((item, index) => {
    //     let currentNum = aS.hasOwnProperty(item) ? (parseInt(aS[item]) + 1) : 1;
    //     aS[item] = currentNum
    //   });

    //   t.split('').forEach((item, index) => {
    //     let currentNum = aT.hasOwnProperty(item) ? (parseInt(aT[item]) + 1) : 1;
    //     aT[item] = currentNum
    //   })

    //   for (let key in aS) {
    //     if (aS[key] !== aT[key]) {
    //       isExist = false
    //       return isExist
    //     }
    //   }
    //   return isExist
    // };

    // console.log(isAnagram('abc', 'cba'))

    // 二叉树：前序遍历
    function TreeNode(val, left, right) {
      this.val = (val === undefined) ? 0 : val
      this.left = (left === undefined) ? null : left
      this.right = (right === undefined) ? null : right
    }

    // @param {TreeNode} root
    // @return {number[]}
    let preOrderTraversal = function (root) {
      let result = []
      let preOrder = (node) => {
        if (node) {
          result.push(node.val)
          preOrder(node.left)
          preOrder(node.right)
        }
      }
      preOrder(root)
      return result
    }

    const root = {
      val: 1,
      left: {
        val: 2,
        left: null,
        right: null
      },
      right: {
        val: 2,
        left: { val: 3, left: null, right: null },
        right: null,
      },
    };

    // preOrderTraversal(root)

    // 两数之和：用hash的方式去做
    // @param {number[]} nums
    // @param {number} target
    // @param {number[]} 数组下标
    // 思路：nums 转换成 
    // [1,2,3,4,5] 6

    let twoSum = function (nums, target) {
      let resultMap = new Map()
      let result = []
      nums.forEach((item, index) => {
        resultMap.set(item, index)
      });
      console.log(resultMap, 'resultMap')
      nums.forEach((item, index) => {
        let anotherNumber = target - item
        console.log(anotherNumber)
        if (resultMap.has(anotherNumber) && (resultMap.get(anotherNumber) !== index) && !result.includes(index)) {
          result.push(index, resultMap.get(anotherNumber));
        }
      })
      return result
    }

    // twoSum([2, 7], 9)


    // 二叉树的中序遍历（左，根，右）
    // const root = {
    //   val: 1,
    //   left: {
    //     val: 2,
    //     left: null,
    //     right: null
    //   },
    //   right: {
    //     val: 2,
    //     left: { val: 3, left: null, right: null },
    //     right: null,
    //   },
    // };
    var inorderTraversal = function (root) {
      let result = []
      let i = 0
      let inOrder = function (node) {
        i++
        if (node) {
          console.log(node, i)
          inOrder(node.left)
          result.push(node.val)
          inOrder(node.right)
        }
      }
      inOrder(root)
      console.log(result)
      return result
    };

    // inorderTraversal(root)

    // 最小的k个数，先排序，再获取
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      let sortArr = arr.sort(function (a, b) {
        return a - b
      })
      let result = []
      for (let i = 0; i < k; i++) {
        result.push(sortArr[i])
      }
      return result
    };

    // 爬楼梯
    var climbStairs = function (n) {
      let dp = []
      dp[0] = 1
      dp[1] = 2
      if (n > 2) {
        for (let i = 2; i < n; i++) {
          dp[i] = dp[i - 1] + dp[i - 2]
        }
      }
      console.log(dp)
      return dp[n - 1];
    };

    // climbStairs(100)

    // 翻转链表
    // linkList
    var reversePrint = function (head) {
      let result = []
      while (head !== null) {
        result.push(head.val)
        head = head.next
      }
      result.reverse()
      return result
    };
    // reversePrint(linkList)

    // 括号生成:生成尽可能多的括号
    // f(0) = 0
    // f(1) = 1
    // f(2) = 2
    // f(3) = 6 + 3 = 9 5

    // f(n) = 2 + f(n-1)) + f(n-2)
    var generateParenthesis = function (n) {
      let result = []
      let prev = []
      if (n === 1) {
        prev = ['()']
      }
      if (n === 2) {
        prev = ['()()', '(())']
      }

      let dp = []
      dp[0] = 1
      dp[1] = 2
      dp[2] = 5
      for (let i = 2; i < n; i++) {
        dp[i] = dp[i - 1] * 2 + dp[i - 2]
      }

      let total = dp[n - 1]
      console.log(total)
      for (let k = 0; k < prev.length; k++) {
        console.log(prev[k])
        result[k] = '()' + prev[k]
      }
      console.log(result)


      // result = generateParenthesis(n - 1) + 2 + generateParenthesis(n - 2)
      // console.log(result)
      return result
    };

    // generateParenthesis(3)



    let bTree = {
      val: 4,
      left: {
        val: 2,
        left: {
          val: 1
        },
        right: {
          val: 3,
          left: {
            val: 11
          }
        }
      },
      right: {
        val: 7,
        left: {
          val: 6
        },
        right: {
          val: 9
        }
      }
    }

    let i = 0
    // 翻转二叉树
    // linkList
    //      4
    //    /   \
    //   2     7
    //  / \  /   \
    // 1   3 6    9
    //    /
    //   11 
    // console.log(bTree, 'bTree')
    var invertTree = function (root) {
      // console.log(root, i++, 'i')
      if (root == null) { // 遍历到null节点时，不用翻转，直接返回它本身
        return root;
      }
      // 递归压栈压到底
      invertTree(root.left);
      invertTree(root.right);
      // 交换
      const temp = root.left;
      // console.log(temp, 'temp')
      root.left = root.right;
      root.right = temp;
      console.log(root)
      return root;
    };


    // invertTree(bTree)

    // 二叉树的最近公共祖先

    var lowestCommonAncestor = function (root, p, q) {

      console.log(root, 'root')
      // console.log(root.hasOwnProperty('right'))
      if (root === undefined) {
        return null
      }
      if ((!root.hasOwnProperty('left')) && (!root.hasOwnProperty('right'))) {
        // console.log(root, 'root1')
        return null
      }
      if ((root.val === p.val) || (root.val === q.val)) {
        console.log(root, 'root2')
        return root;
      }

      // console.log(root.left)
      let left = lowestCommonAncestor(root.left, p, q);
      let right = lowestCommonAncestor(root.right, p, q);
      // console.log('right', right)

      console.log('left', left)
      if (left && right) {
        console.log(root, 'root 3')
        return root;
      }
      // console.log(left, 'root 7')
      if (left === null) {
        console.log(right, 'root 4')
        return right
      }

      // console.log(left, 'root 5')
      return left;
    };
    // linkList
    //      4
    //    /   \
    //   2     7
    //  / \  /   \
    // 1   3 6    9
    //    /
    //   11 
    // console.log(lowestCommonAncestor(bTree, bTree.right.right, bTree.right.right), 'result')
    // console.log()

    function ListNode(val) {
      this.val = val
      this.next = null
      this.prev = null
    }

    /**
     * Initialize your data structure here. Set the size of the deque to be k.
     * @param {number} k
     */
    var MyCircularDeque = function (k) {
      this.head = new ListNode('head')
      this.last = new ListNode('last')
      this.head.next = this.last
      this.last.prev = this.head
      this.length = 0
      this.max = k
    };

    /**
     * Adds an item at the front of Deque. Return true if the operation is successful. 
     * @param {number} value
     * @return {boolean}
     */
    MyCircularDeque.prototype.insertFront = function (value) {
      if (this.isFull()) { return false }
      let now = new ListNode(value)
      let next = this.head.next
      now.next = next
      now.prev = this.head
      next.prev = now
      this.head.next = now
      this.length++

      return true
    };

    /**
     * Adds an item at the rear of Deque. Return true if the operation is successful. 
     * @param {number} value
     * @return {boolean}
     */
    MyCircularDeque.prototype.insertLast = function (value) {
      if (this.isFull()) { return false }
      let now = new ListNode(value)
      let prev = this.last.prev
      now.prev = prev
      now.next = this.last
      prev.next = now
      this.last.prev = now
      this.length++

      return true
    };

    /**
     * Deletes an item from the front of Deque. Return true if the operation is successful.
     * @return {boolean}
     */
    MyCircularDeque.prototype.deleteFront = function () {
      if (this.isEmpty()) { return false }
      let now = this.head.next
      let next = now.next
      next.prev = this.head
      this.head.next = next
      this.length--

      return true
    };

    /**
     * Deletes an item from the rear of Deque. Return true if the operation is successful.
     * @return {boolean}
     */
    MyCircularDeque.prototype.deleteLast = function () {
      if (this.isEmpty()) { return false }
      let now = this.last.prev
      let prev = now.prev
      prev.next = this.last
      this.last.prev = prev
      this.length--

      return true
    };

    /**
     * Get the front item from the deque.
     * @return {number}
     */
    MyCircularDeque.prototype.getFront = function () {
      if (this.isEmpty()) { return -1 }
      return this.head.next.val
    };

    /**
     * Get the last item from the deque.
     * @return {number}
     */
    MyCircularDeque.prototype.getRear = function () {
      if (this.isEmpty()) { return -1 }
      return this.last.prev.val
    };

    /**
     * Checks whether the circular deque is empty or not.
     * @return {boolean}
     */
    MyCircularDeque.prototype.isEmpty = function () {
      return !this.length
    };

    /**
     * Checks whether the circular deque is full or not.
     * @return {boolean}
     */
    MyCircularDeque.prototype.isFull = function () {
      return this.length >= this.max
    };

    /**
     * Your MyCircularDeque object will be instantiated and called as such:
     * var obj = new MyCircularDeque(k)
     * var param_1 = obj.insertFront(value)
     * var param_2 = obj.insertLast(value)
     * var param_3 = obj.deleteFront()
     * var param_4 = obj.deleteLast()
     * var param_5 = obj.getFront()
     * var param_6 = obj.getRear()
     * var param_7 = obj.isEmpty()
     * var param_8 = obj.isFull()
     */

    // 全排列[1,2,3]
    const permute = (nums) => {
      const res = [];
      const used = {};

      function dfs(path) {
        if (path.length == nums.length) {
          console.log(path)
          res.push(path.slice());
          return;
        }
        for (const num of nums) {
          // if (path.includes(num)) continue; // 查找的时间是O(n)，别这么写，时间复杂度增加
          if (used[num]) continue;
          path.push(num);
          used[num] = true;
          dfs(path);
          path.pop();
          used[num] = false;
        }
      }

      dfs([]);
      console.log(res)
      return res;
    };

    // permute([1, 2, 3])


    // 122. 买卖股票的最佳时机 II 贪心算法
    var maxProfit = function (prices) {
      let ans = 0;
      let n = prices.length
      for (let i = 1; i < n; i++) {
        ans = ans + Math.max(0, prices[i] - prices[i - 1])
      }
      return ans
    };

    // 组合
    // 1->n 
    // 递归 [1,2,3,4] => 2个数字组合
    // 使用回溯算法
    var combine = function (n, k) {
      let result = [];

      const helper = (start, path) => {
        console.log('recursion start path', start, path)
        if (path.length === k) {
          result.push(path.slice())
          console.log('full end path', path)
          return
        }
        for (let j = start; j < n + 1; j++) {
          console.log('loop1')
          console.log(j, 'j')
          path.push(j)
          helper(j + 1, path)
          console.log('path pop start', path)
          path.pop()
          console.log('path pop end', path)
        }
      }

      helper(1, []);
      console.log(result)
      return result
    };

    // combine(4, 2)


    /**
   * @param {number} x
   * @param {number} n
   * @return {number}
   */
    // x的n次幂函数
    // 暴力方法
    var myPow2 = function (x, n) {
      let result = 1
      for (let j = 0; j < n; j++) {
        result = result * x
      }
      return result
    };


    // 二分法
    var myPow = function (x, n) {
      if (x === 0) { return 0 }
      if (n === 0) { return 1 }
      if (n < 0) { return 1 / myPow(x, -n) }
      if (n % 2) {
        // n is odd
        return x * myPow(x, n - 1)
      }

      return myPow(x * x, n / 2)
    };

    // console.log(myPow(2, -2))


    // 多数元素
    var majorityElement = function (nums) {
      let elementMap = new Map()
      for (let i = 0; i < nums.length; i++) {
        elementMap.set(nums[i], elementMap.has(nums[i]) ? (elementMap.get(nums[i]) + 1) : 1);
      }
      let benchmark = nums.length / 2
      let result = []
      for (const element of elementMap) {
        if (element[1] >= benchmark) {
          result.push(element[0])
        }
      }
      return result
    };

    // majorityElement([1, 9, 2, 2, 2, 3])

    // 凌檬水找零
    var lemonadeChange = function (bills) {
      let five = 0;
      let ten = 0;
      for (const item of bills) {
        if (item === 5) {
          five++
        } else if (item === 10) {
          if (five === 0) {
            return false
          }
          ten++
          five--
        } else {
          if ((five > 0 && ten > 0)) {
            ten--;
            five--;
          } else if (five > 2 && ten === 0) {
            five = five - 3;
          } else {
            return false
          }
        }
      }

      return true
    };

    









  </script>

</body>

</html>